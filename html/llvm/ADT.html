<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>LLVM ADT</title>
</head>
<body>
	<p>ADT的头文件在include/llvm/ADT目录下，部分需要.cpp文件的，相应的.cpp文件在lib/Support目录下，例如lib/Support/APInt.cpp. Support目录下是一些为了隔离开操作系统依赖，便于移植的功能性library，你可以浏览一下这两个目录的内容，感受一下它们的不同．ADT都位于namespace llvm下，部分Support库的内容位于llvm::support下，其他也直接在namespace llvm下. 对于header-only的ADT库，直接引用头文件就可以使用，例如include/llvm/ADT/EquivalenceClasses.h就是一个header-only的头文件，不是header-only的需要动态/静态链接到相应的libLLVM.so/libLLVM.a等目标库文件. 似乎ADT和Support都只依赖于C++标准库，config和对方(除了部分Support的实现依赖platform specific header, 例如lib/Support/Unix, lib/Support/Windows, 以及include/llvm/Support/Solaris/sys/regset.h这个workaround).</p>
	<p>下面简单介绍一下ADT中各个组件的功能和部分实现细节.</p>
	<p>图及其遍历.</p>
	GraphTraits
	BreadthFirstIterator
	DepthFirstIterator
	PostOrderIterator
	SCCIterator
	<p>容器1.</p>
	<p>容器2 哈希表.</p>
        <a href="http://llvm.org/doxygen/classllvm_1_1DebugEpochBase.html">DebugEpochBase</a>和<a href="http://llvm.org/doxygen/classllvm_1_1DebugEpochBase_1_1HandleBase.html">llvm::DebugEpochBase::HandleBase </a>.哈希表当rehash/rebucket发生时，会invalidate掉旧的iterator，为了帮助调试这类误用invalid iterator的错误，考虑这样:
        <p>为哈希表增加一个int型变量epoch;</p>
        <p>当rehash发生时，inc epoch;</p>
        <p>为每个hash_table::iterator增加一个int型变量epoch,记录创建这个itor时哈希表的epoch值;</p>
        <p>当使用itor访问哈希表时,assert(itor.epoch == hash_table.epoch);</p>
        <p>DebugEpochBase和DebugEpochBase::HandleBase就factor out了这部分功能，你的容器和迭代器需要继承这两个类，在合适的时间调用操作epoch的方法.这两个类的定义均conditiond on LLVM_ENABLE_ABI_BREAKING_CHECKS这个宏，没定义这个宏时相应操作为nop．目前DenseMap和SmallPtrSet使用了这个功能.</p>
        下面这些是关于哈希表的数据结构.
        <p>DenseMap</p>
        <p>DenseSet</p>
        <p>DenseMapInfo</p>
        <p>Hashing</p>
        <p>StringMap</p>
        关于哈希表有三个方面需要考虑:
        <p> 1. 如何计算一个类型的哈希值.</p>
        <p> 2. 对哈希表模板来说，它怎么知道如何计算哈希值/获取empty key/获取tombstone key/判断两个object是否"=="</p>
        <p> 3. 哈希表是open addressing/separate chaining, rehash策略, 碰撞处理策略</p>
        对于这三个问题的解答:
        <p> 1. LLVM提供了hash_combine，你不再需要直接根据你的类型的成员变量计算出哈希值,你只用使用hash_combine来表达，例如:根据长度len, 和指针的地址ptr来计算哈希值;或者根据指针ptr指向的位置及其后面len个字节的内容来计算哈希值.这样做的好处是，设计一个好的哈希函数是一件困难，并且实现起来容易出错的事情，你并不希望每天都要做这种工作，但是指定某个类型的哪些数据成员构成哈希函数的输入是一件简单，不容易出错，并且与哈希函数的设计解耦合的一件事情.这部分功能也是一个新的C++提案<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3333.html">N3333</a>.你可以阅读<a href="http://llvm.org/doxygen/Hashing_8h_source.html">Hashing.h</a>的注释来了解更多内容.
        <p> 2. DenseMap的第二个模板类形参是<a href="https://github.com/llvm-mirror/llvm/blob/ae1ca02d148ec1e591d38a71f429b4804a07f638/include/llvm/ADT/DenseMap.h#L643">KInfoT</a>，默认为DenseMapInfo&lt KeyT&gt ,这个类应该提供如下<a href="https://github.com/llvm-mirror/llvm/blob/ae1ca02d148ec1e591d38a71f429b4804a07f638/include/llvm/ADT/DenseMapInfo.h#L29"> static方法</a>，DenseMap通过这个traits类来操纵KeyT，你可以特化/偏特化DenseMapInfo，或者给DenseMap传入其他的traits来自定义DenseMap.</p>
        <p> 3. 这个哈希表相关的数据结构，均为open addressing(也即，bucket直接存在<a href="https://github.com/llvm-mirror/llvm/blob/ae1ca02d148ec1e591d38a71f429b4804a07f638/include/llvm/ADT/DenseMap.h#L653">数组</a>中，而不是另外存在linked-list中);rehash实现在<a href="https://github.com/llvm-mirror/llvm/blob/ae1ca02d148ec1e591d38a71f429b4804a07f638/include/llvm/ADT/DenseMap.h#L728">这里</a>，除了reserve外的rebucket策略在<a href="https://github.com/llvm-mirror/llvm/blob/ae1ca02d148ec1e591d38a71f429b4804a07f638/include/llvm/ADT/DenseMap.h#L534">这里</a>，注释很清楚，不用解释了;查找bucket的实现在<a href="https://github.com/llvm-mirror/llvm/blob/ae1ca02d148ec1e591d38a71f429b4804a07f638/include/llvm/ADT/DenseMap.h#L573">这里</a>，quadratic probing在<a href="https://github.com/llvm-mirror/llvm/blob/ae1ca02d148ec1e591d38a71f429b4804a07f638/include/llvm/ADT/DenseMap.h#L616<Paste>">这里</a>;空的bucket是EmptyKey，删去一个bucket在原位置放TombStone，找bucket时需要持续探查到第一个EmptyKey，然后返回路上遇到的第一个TomStone或者没有遇到TomStone时返回这个EmptyKey．

	<p>容器2 intrusive list.</p>
	ilist
	<p>容器3 其他容器</p>
	EquivalenceClasses并查集.
	FoldingSet另一种哈希表.
	<p>任意精度整数，浮点数.</p>
	<p>标准库扩展</p>
	None
	Optional
	iterator
	iterator_range
	STLExtras
	<p>小工具.</p>
	StringRef/Twine
	IntrusiveRefCntPtr
	PointerIntPair
</body>
